test_level: parse,ast
text: |-
  int global_i = 0;
  char global_c = 't';
  string global_s = "hello!\n";
  int gi;
  char gc;
  
  void putc(char c);
  void puts(string s);
  void puti(int i);
  
  void f() {
      return;
  }
  
  void g() {
         if (0) int a;
         if (0) {
          int a;
         }
         if (0) {
              int a;
              int b;
         } else {
              int b;
         }
         while(1) {
  
         }
  
          int a;
          int b = 0;
          int c = b;
  
          break;
          continue;
          return;
          return 1;
      a;
      1;
      a(1, a, 2);
      1 ? 2 : 3;
  
      -1;
      -a;
      !a;
      // a++;
      a--;
  
      1 + (N * 3);
  
      1 < (4 * 5) ? f() + 3-- : 5++;
  
  }
  
  
  int g(int a, char b) {
      int c = 0;
      c = c + a;
      b = a * c;
      int d = a + b + c;
      return d % 10;
  }
  
  int h(int x) {
      if (x == 0) {
          return 1;
      }
      int b = -1;
      if ((x * 5) < 10) {
          b = 10;
          b = b * x;
      }
      return b;
  }
  
  int j() {
      int c = 0;
      /*
      puts("->");
      */
      while (c++ < 10) {
          puti(c);
          puts("\n->");
      }
  }
  
  void main() {
      j();
  }

ast_tree: Tree(Token('RULE', 'start'), [Tree(Token('RULE', 'decl_fun'), [Tree(Token('RULE',
  'decl_fun_sig'), [Token('TYP', 'void'), Token('CNAME', 'main')]), Tree(Token('RULE',
  'block'), [Tree(Token('RULE', 'statements'), [Tree(Token('RULE', 'statement'), [Tree(Token('RULE',
  'decl_var'), [Tree(Token('RULE', 'var_sig'), [Token('TYP', 'int'), Token('CNAME',
  'a')]), None])]), Tree(Token('RULE', 'statement'), [Tree(Token('RULE', 'decl_var'),
  [Tree(Token('RULE', 'var_sig'), [Token('TYP', 'int'), Token('CNAME', 'b')]), Tree(Token('RULE',
  'expression'), [Tree(Token('RULE', 'literal'), [Tree(Token('RULE', 'lit_int'), [12])])])])]),
  Tree(Token('RULE', 'statement'), [Tree(Token('RULE', 'decl_var'), [Tree(Token('RULE',
  'var_sig'), [Token('TYP', 'char'), Token('CNAME', 'c')]), Tree(Token('RULE', 'expression'),
  [Tree(Token('RULE', 'literal'), [Tree(Token('RULE', 'lit_char'), ['a'])])])])]),
  Tree(Token('RULE', 'statement'), [Tree(Token('RULE', 'decl_var'), [Tree(Token('RULE',
  'var_sig'), [Token('TYP', 'int'), Token('CNAME', 's')]), Tree(Token('RULE', 'expression'),
  [Tree(Token('RULE', 'literal'), [Tree(Token('RULE', 'lit_string'), ['a', 's', 'd',
  '\n', '\t', '\\', '"', 'd', 's', 'a'])])])])])])])])])
parse_tree: |
  start
    decl_fun
      decl_fun_sig
        void
        main
      block
        statements
          statement
            decl_var
              var_sig
                int
                a
              None
          statement
            decl_var
              var_sig
                int
                b
              expression
                literal
                  lit_int	12
          statement
            decl_var
              var_sig
                char
                c
              expression
                literal
                  lit_char	a
          statement
            decl_var
              var_sig
                int
                s
              expression
                literal
                  lit_string
                    a
                    s
                    d
                    \n
                    \t
                    \\
                    \"
                    d
                    s
                    a
